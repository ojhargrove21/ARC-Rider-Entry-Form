<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5,user-scalable=yes">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      box-sizing: border-box;
      background: #f9f9f9;
    }

    body { padding: 20px; margin: auto; }

    h1 { text-align: center; margin-bottom: 20px; }

    label, .section_label {
      font-weight: bold;
      display: block;
      margin-top: 15px;
    }

    input, select, button {
      width: 100%;
      padding: 10px;
      margin-top: 5px;
      margin-bottom: 10px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }

    input[readonly] { background-color: #eee; }

    .section-divider {
      border-top: 1px solid #ccc;
      margin: 30px 0;
    }

    /* Dropdown desktop */
    .dropdown { position: relative; width: 100%; }

    .dropdown button {
      width: 100%;
      text-align: left;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 10px;
    }

    .dropdown-content {
      display: none;
      position: absolute;
      width: 100%;
      max-height: 200px;
      overflow-y: auto;
      background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 4px;
      z-index: 10;
      box-sizing: border-box;
    }

    .dropdown-content label {
      display: block;
      padding: 5px 10px;
      cursor: pointer;
    }

    .dropdown-content label:hover { background-color: #f0f0f0; }

    /* Modal for mobile */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background-color: rgba(0,0,0,0.5);
      z-index: 9999;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: #fff;
      width: 90%;
      max-width: 400px;
      max-height: 80vh;
      overflow-y: auto;
      border-radius: 8px;
      padding: 20px;
      box-sizing: border-box;
    }

    .modal-header { font-weight: bold; margin-bottom: 10px; }

    .modal label {
      display: block;
      padding: 10px;
      cursor: pointer;
      border-bottom: 1px solid #ddd;
    }

    .modal button { margin-top: 10px; }
  </style>
  <title>Entry Form</title>
</head>

<body>
  <h1 role="main">Entry Form</h1>

  <label for="number">Rider Number:</label>
  <input id="number" list="riderNumbers" placeholder="Select or type Rider Number" onchange="loadRider()">
  <datalist id="riderNumbers"></datalist>

  <label for="firstName">First Name:</label>
  <input id="firstName" readonly>

  <label for="lastName">Last Name:</label>
  <input id="lastName" readonly>

  <label for="age">Age:</label>
  <input id="age" type="number">

  <label for="division">Division</label>
  <select id="division" onchange="loadCheckboxes()">
    <option value="">-- Select Division --</option>
  </select>

  <label for="horse">Horse Name:</label>
  <input id="horse" readonly>

  <div class="section-divider"></div>

  <div class="section_label">Select Classes:</div>
  <div class="dropdown" id="dropdownContainer">
    <button type="button" id="classDropdownBtn">Select Classes</button>
    <div class="dropdown-content" id="classDropdownContent"></div>
  </div>

  <div class="modal" id="classModal">
    <div class="modal-content" id="classModalContent">
      <div class="modal-header">Select Classes</div>
      <div id="modalCheckboxes"></div>
      <button type="button" onclick="closeModal()">Done</button>
    </div>
  </div>

  <button type="button" onclick="submitForm()">Submit</button>

  <script>
    // âœ… MUST be the deployed /exec URL, not /dev
    const API_BASE = "https://script.google.com/macros/s/AKfycbzU8OQvR76mXK_sE6hxpYr3Aj-ZyEmd15bfeyNptz-nJyzAwGxXmMc7DSdJVHtCxKZ7Xg/exec";

    /*****************************************************************
     * GROUPED CACHE (per "page/sheet group") using getVersions
     *
     * Requires Code.gs to support:
     *   GET ?action=getVersions
     * returning:
     *   { riders:"...", divisions:"...", classes:"...", altClasses:"...", events:"...", entries:"..." }
     *
     * We cache GET responses in localStorage with a "group" prefix:
     *   entryform:riders:...
     *   entryform:divisions:...
     *   entryform:classes:...
     *   entryform:events:...
     *
     * When a group version changes, we clear ONLY that group's keys.
     *****************************************************************/
    const CACHE_PREFIX = "entryform:";
    const VERSION_STORE_KEY = CACHE_PREFIX + "versions";
    const CACHE_TTL_MS = 6 * 60 * 60 * 1000; // safety fallback (6h)

    // Map each API action to a "group" (choose groups that match your sheet tabs)
    function groupForAction(action) {
      switch (action) {
        // Riders sheet
        case "getRiderNumberMap":
        case "findRider":
          return "riders";

        // Divisions sheet
        case "getDivisions":
          return "divisions";

        // Classes depend on Events + (Classes/Alternate Classes). We treat as "classes"
        case "getClasses":
          return "classes";

        // If you later add endpoints, map them here.
        default:
          return "misc";
      }
    }

    // Which server versions should invalidate a group?
    // You can tune this logic. For getClasses, changes to events OR classes OR altClasses matter.
    function dependsOnVersions(group) {
      switch (group) {
        case "riders":
          return ["riders"];
        case "divisions":
          return ["divisions"];
        case "classes":
          return ["events", "classes", "altClasses"]; // all can affect class list
        default:
          return ["events", "classes", "altClasses", "riders", "divisions", "entries"];
      }
    }

    async function rawApiGet(action, params = {}) {
      const url = new URL(API_BASE);
      url.searchParams.set("action", action);
      Object.entries(params).forEach(([k, v]) => {
        if (v !== undefined && v !== null) url.searchParams.set(k, v);
      });

      const res = await fetch(url.toString(), { method: "GET", redirect: "follow" });
      if (!res.ok) throw new Error("GET failed: " + res.status);
      return await res.json();
    }

    async function rawApiPost(action, payloadObj) {
      const body = new URLSearchParams();
      body.set("action", action);
      body.set("payload", JSON.stringify(payloadObj || {}));

      const res = await fetch(API_BASE, { method: "POST", body, redirect: "follow" });
      const out = await res.json().catch(() => ({}));
      return { res, out };
    }

    async function getServerVersions() {
      // Code.gs must support this
      const v = await rawApiGet("getVersions");
      // Normalize values to strings
      return {
        riders: String(v.riders || "0"),
        divisions: String(v.divisions || "0"),
        classes: String(v.classes || "0"),
        altClasses: String(v.altClasses || "0"),
        events: String(v.events || "0"),
        entries: String(v.entries || "0"),
      };
    }

    function loadLocalVersions() {
      try {
        const raw = localStorage.getItem(VERSION_STORE_KEY);
        if (!raw) return null;
        const v = JSON.parse(raw);
        if (!v || typeof v !== "object") return null;
        return v;
      } catch {
        return null;
      }
    }

    function saveLocalVersions(v) {
      try { localStorage.setItem(VERSION_STORE_KEY, JSON.stringify(v)); } catch {}
    }

    function clearGroupCache(group) {
      const prefix = `${CACHE_PREFIX}${group}:`;
      Object.keys(localStorage).forEach(k => {
        if (k.startsWith(prefix)) localStorage.removeItem(k);
      });
    }

    function cacheKeyFor(group, action, params) {
      return `${CACHE_PREFIX}${group}:${action}:${JSON.stringify(params || {})}`;
    }

    function readCache(key) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || typeof obj !== "object") return null;
        if (!obj.savedAt) return null;
        if ((Date.now() - obj.savedAt) > CACHE_TTL_MS) return null;
        return obj.data;
      } catch {
        return null;
      }
    }

    function writeCache(key, data) {
      try { localStorage.setItem(key, JSON.stringify({ savedAt: Date.now(), data })); } catch {}
    }

    let _versionsPromise = null;

    async function ensureVersionsFresh() {
      if (_versionsPromise) return _versionsPromise;

      _versionsPromise = (async () => {
        const serverV = await getServerVersions();
        const localV = loadLocalVersions();

        if (!localV) {
          // First time: store versions but don't clear anything
          saveLocalVersions(serverV);
          return serverV;
        }

        // Compare per-version key; clear only groups that depend on a changed version
        const changed = [];
        Object.keys(serverV).forEach(k => {
          if (String(localV[k] || "0") !== String(serverV[k] || "0")) changed.push(k);
        });

        if (changed.length) {
          // For each group, if any dependency changed, clear that group's cache
          const groups = ["riders", "divisions", "classes", "misc"];
          groups.forEach(g => {
            const deps = dependsOnVersions(g);
            const hit = deps.some(dep => changed.includes(dep));
            if (hit) clearGroupCache(g);
          });

          // Save new versions
          saveLocalVersions(serverV);
        }

        return serverV;
      })();

      return _versionsPromise;
    }

    async function apiGet(action, params = {}) {
      // Do not cache version calls themselves
      if (action === "getVersions") return rawApiGet(action, params);

      // Ensure we only clear the specific group caches that must be cleared
      await ensureVersionsFresh();

      const group = groupForAction(action);
      const key = cacheKeyFor(group, action, params);

      const cached = readCache(key);
      if (cached !== null) return cached;

      const data = await rawApiGet(action, params);

      // Don't cache errors
      if (data && typeof data === "object" && data.error) return data;

      writeCache(key, data);
      return data;
    }

    // Optional: refresh versions periodically for long-open pages
    setInterval(() => {
      _versionsPromise = null;
      ensureVersionsFresh().catch(() => {});
    }, 120000); // every 2 min

    // ---------- helpers ----------
    function setFieldState(readOnly) {
      ["firstName", "lastName", "horse"].forEach(id => document.getElementById(id).readOnly = readOnly);
    }

    // ---------- init ----------
    document.addEventListener("DOMContentLoaded", async () => {
      await populateDivisions();
      await buildRiderNumberList();
    });

    // ---------- divisions ----------
    async function populateDivisions() {
      const divisions = await apiGet("getDivisions");
      const select = document.getElementById("division");
      divisions.forEach(d => {
        const option = document.createElement("option");
        option.value = d;
        option.textContent = d;
        select.appendChild(option);
      });
    }

    // ---------- rider numbers (include 1-200 + >200 in sheet) ----------
    async function buildRiderNumberList() {
      const existingMap = await apiGet("getRiderNumberMap");

      const datalist = document.getElementById("riderNumbers");
      datalist.innerHTML = "";

      for (let i = 1; i <= 200; i++) {
        const option = document.createElement("option");
        option.value = i;
        if (existingMap[i]) option.label = existingMap[i];
        datalist.appendChild(option);
      }

      Object.keys(existingMap)
        .map(Number)
        .filter(n => n > 200)
        .sort((a, b) => a - b)
        .forEach(n => {
          const option = document.createElement("option");
          option.value = n;
          option.label = existingMap[n];
          datalist.appendChild(option);
        });
    }

    // ---------- load rider ----------
    async function loadRider() {
      const number = document.getElementById("number").value;
      if (!number) return;

      const rider = await apiGet("findRider", { number });

      if (rider.exists) {
        firstName.value = rider.firstName || "";
        lastName.value = rider.lastName || "";
        age.value = rider.age || "";
        horse.value = rider.horse || "";
        setFieldState(true);
      } else {
        firstName.value = "";
        lastName.value = "";
        age.value = "";
        horse.value = "";
        setFieldState(false);
      }
    }

    // ---------- load classes ----------
    async function loadCheckboxes() {
      const division = document.getElementById("division").value;
      if (!division) return;

      const items = await apiGet("getClasses", { division });
      renderClasses(items);
    }

    function renderClasses(items) {
      const desktopContainer = document.getElementById("classDropdownContent");
      const modalContainer = document.getElementById("modalCheckboxes");
      desktopContainer.innerHTML = "";
      modalContainer.innerHTML = "";

      items.forEach((item, i) => {
        // Desktop
        const label = document.createElement("label");
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.value = item;
        cb.id = "class_" + i;
        label.appendChild(cb);
        label.appendChild(document.createTextNode(" " + item));
        desktopContainer.appendChild(label);

        // Mobile modal
        const mlabel = document.createElement("label");
        const mcb = document.createElement("input");
        mcb.type = "checkbox";
        mcb.value = item;
        mcb.id = "modal_" + i;
        mlabel.appendChild(mcb);
        mlabel.appendChild(document.createTextNode(" " + item));
        modalContainer.appendChild(mlabel);
      });
    }

    // Dropdown toggle
    document.getElementById("classDropdownBtn").addEventListener("click", () => {
      if (window.innerWidth > 600) {
        const container = document.getElementById("classDropdownContent");
        container.style.display = container.style.display === "block" ? "none" : "block";
      } else {
        document.getElementById("classModal").style.display = "flex";
        syncModalCheckboxes();
      }
    });

    function closeModal() {
      document.getElementById("classModal").style.display = "none";
      syncDesktopCheckboxes();
    }

    function syncDesktopCheckboxes() {
      const modalChecks = document.querySelectorAll("#modalCheckboxes input");
      const desktopChecks = document.querySelectorAll("#classDropdownContent input");
      modalChecks.forEach((mcb, i) => { if (desktopChecks[i]) desktopChecks[i].checked = mcb.checked; });
    }

    function syncModalCheckboxes() {
      const modalChecks = document.querySelectorAll("#modalCheckboxes input");
      const desktopChecks = document.querySelectorAll("#classDropdownContent input");
      modalChecks.forEach((mcb, i) => { if (desktopChecks[i]) mcb.checked = desktopChecks[i].checked; });
    }

    // ---------- submit ----------
    async function submitForm() {
      const selected = [...document.querySelectorAll("#classDropdownContent input:checked")].map(cb => cb.value);

      const data = {
        number: number.value,
        firstName: firstName.value,
        lastName: lastName.value,
        age: +age.value,
        division: division.value,
        horse: horse.value,
        classes: selected
      };

      if (!data.number || data.classes.length === 0) {
        alert("Rider Number and at least one class are required.");
        return;
      }

      const { res, out } = await rawApiPost("submitForm", data);

      if (!res.ok || out.error) {
        console.error("Submit error:", out);
        alert("Submit failed: " + (out.error || res.statusText));
        return;
      }

      // After a successful submit:
      // - Riders + Entries versions likely changed on the server
      // - So re-check versions; this will clear ONLY the affected groups
      _versionsPromise = null;
      await ensureVersionsFresh().catch(() => {});

      // Optional: refresh UI lists (only needed if you want the datalist updated immediately)
      // await buildRiderNumberList();

      alert("Form submitted!");
    }

    // ----- CLOSE MODAL ONLY WHEN CLICKING THE BACKDROP -----
    const classModal = document.getElementById("classModal");
    const classModalContent = document.getElementById("classModalContent");

    classModal.addEventListener("click", (e) => {
      if (e.target === classModal) closeModal();
    });

    classModalContent.addEventListener("click", (e) => {
      e.stopPropagation();
    });

    // ----- CLOSE DESKTOP DROPDOWN WHEN CLICKING OUTSIDE -----
    const dropdownContainer = document.getElementById("dropdownContainer");
    const dropdownContent = document.getElementById("classDropdownContent");

    document.addEventListener("click", (e) => {
      if (window.innerWidth <= 600) return;
      if (!dropdownContainer.contains(e.target)) dropdownContent.style.display = "none";
    });

    // ----- ESC KEY CLOSES MODAL & DROPDOWN -----
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        if (classModal.style.display === "flex") closeModal();
        dropdownContent.style.display = "none";
      }
    });
  </script>
</body>
</html>
